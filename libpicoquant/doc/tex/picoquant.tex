\documentclass{article}

\title{\texttt{picoquant}: Software for decoding PicoQuant data formats}
\author{Thomas Bischof \\ \texttt{tbischof@mit.edu}}

\begin{document}
\maketitle

\section{Picoquant}
\subsection{Purpose}
This program decodes binary data from the Picoquant software and outputs the data in human-readable format. Currently, \program{picoquant} supports most modes and versions of the Timeharp, Picoharp, and Hydraharp. The board and mode are detected automatically, and if the mode is not supported an error message will explain the details.

Modes and software versions supported:
\begin{itemize}
\item Timeharp: v20 (thd), v30 (thd, t3r), v50 (thd), v60 (thd, t3r)
\item Picoharp: v20 (phd, pt2, pt3)
\item Hydraharp: v10 (hhd, ht2, ht3)
\end{itemize}

\subsection{Command-line syntax}
%\input{programs/picoquant.usage}

\subsubsection{Input}
The input is either binary stream of data from the timing hardware, or the name of a file containing that data. The details of each format are too varied and verbose to be summarized here, but are laid out in section~\ref{sec:formats}.

\subsubsection{Output}
\label{sec:picoquant_output}
The output will either be written to \stdout{} or the file specified. The output format depends on the mode of the data (interactive, t2, t3), with details given below.

\paragraph{Interactive}
Each record is of the form:
\begin{verbatim}
struct {
    int curve;
    double left_edge;
    double right_edge;
    int counts;
};
\end{verbatim}
printed as:
\begin{verbatim}
curve number, left edge of time bin, right edge of bin, counts \n
\end{verbatim}

\paragraph{T2}
Each record is of the form:
\begin{verbatim}
struct {
    int channel;
    long long time;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, time \n
\end{verbatim}

\paragraph{T3}
Each record is of the form:
\begin{verbatim}
struct {
    int channel;
    long long pulse_number;
    int time;
};
\end{verbatim}
printed as:
\begin{verbatim}
channel number, pulse number, time \n
\end{verbatim}
	
\subsection{Examples of usage}
\subsubsection{Reading header information}
\begin{verbatim}
> picoquant --file-in data.phd --header-only
Ident = PicoHarp 300
FormatVersion = 2.0
CreatorName = PicoHarp Software
CreatorVersion = 2.3.0.0
FileTime = 14/05/11 17:55:48
Comment = Untitled
NumberOfCurves = 8
   ....
\end{verbatim}

Reading these values is often a good way to check the integrity of a file, and to make sure that the correct settings are used in later processing. The keywords used here are consistent with those used in the documentation for the file type as provided by Picoquant, so common values like measurement resolution may not be identical across versions and boards. 

\subsubsection{Obtaining the resolution of a measurement}
Resolution values must be multiples of 1\pico\second{} for most of the devices, but for the Timeharp they are integer divisions of 1\nano\second, leading to non-integer multiples of 1\pico\second. As such, all resolution values are presented as floats, even those which could be written as integers.
\begin{verbatim}
> picoquant --file-in data.phd --resolution-only
0,1.280000e+02
1,1.280000e+02
2,1.280000e+02
3,1.280000e+02
4,1.280000e+02
5,5.120000e+02
6,1.280000e+02
\end{verbatim}
Interactive mode allows for a large number of curves, so the resolution report gives the resolution for each curve, by index.
\begin{verbatim}
> picoquant --file-in data.pt2 --resolution-only
1.280000e+02
\end{verbatim}

\subsubsection{Reading interactive data}
\begin{verbatim}
> picoquant --file-in data.phd
0,0.000,0
...
3,4.482,4.484,2620
3,4.484,4.486,2595
3,4.486,4.488,2601
3,4.488,4.490,2604
3,4.490,4.492,2447
3,4.492,4.494,2407
3,4.494,4.496,2418
...
\end{verbatim}

\subsubsection{Reading T2/T3 data}
\begin{verbatim}
> picoquant --file-in data.pt2
0,7128264
0,20957636
0,33684532
0,36576452
0,42146280
0,42251400
0,65787700
0,75149552
0,86537580
0,109288316
> picoquant --file-in data.pt3
1,103,47360
1,109,47616
1,115,85760
1,115,248832
1,213,55552
1,245,244992
1,254,49920
1,267,69888
1,268,122368
1,274,58624
\end{verbatim}

\subsubsection{Translating T3 data to T2 data}
\begin{verbatim}
> picoquant --file-in data.pt3 --to-t2
1,41248184
1,43648488
1,46086680
1,46249752
1,85257256
1,98246952
1,101651952
1,106872024
1,107324512
1,109660816
\end{verbatim}

\subsection{Mode- and hardware-specific information}
\label{sec:formats}

While there are many differences between the formats of the files generated by the different boards and modes, they all follow a common structure:
\begin{itemize}
\item a general header identifying the board type and software version
\item a board-specific header, identifying hardware and software configuration
\item a mode-specific header
\item data
\end{itemize}

As such, the process of streaming data can be broken down into the following steps:
\begin{enumerate}
\item Identify the board type (\texttt{picoquant.c})
\item Identify the software version used to generate the file (\texttt{hydraharp.c}, \texttt{picoharp.c}, \texttt{timeharp.c}).
\item Determine the collection mode used (\texttt{hydraharp/hh\_*.c}, $\ldots$).
\item  \begin{enumerate}
  \item If the run is specified as resolution-only or header-only, print the appropriate values.
  \item Otherwise, read through the remaining header information and print the data.
  \end{enumerate}
\end{enumerate}

In this implementation, while the code used to produce the data and headers is very similar between software versions for a given board, there are some small differences which make a general program difficult to write. As such, each version is hard-coded, and any changes to the overall structure of the program must be rolled out to all versions. Fortunately, many common tasks such as printing of data are centralized in \texttt{picoquant.c}, so changes to the output format only require modification of a single function.

In principle, the code can be collected into a nicer data-streaming object which masks the translation process and yields only the resulting data stream. This is probably the most convenient way to deal directly with developing custom tools for data processing, but for most purposes passing the data through pipes should be sufficient. If such an interface is desired, the low-level translation functions (found in \texttt{*/*\_v*.c}) should be sufficient when wrapped with higher-level logical routines like those used to determine the board identity and version. The function structure is uniform across all versions and boards, which should simplify the wrapping process.

The remainder of this section is devoted to a discussion of the details important to each board and measurement type. Most of this information can be found in the manuals included with the hardware, but there is a significant amount of information which is documented in more scattered locations, such as the sample data code. This summary includes the details vital to understanding how the raw data are actually translated into the general data streams, and how various design decisions affect the quality and precision of the result.

\subsubsection{A word about external markers}
Many of the timing boards have a feature which allows the insertion of an external timing pulse into the signal, for use in TTTR modes to designate a raster scan or other time-dependent behavior. These records are not handled directly by \program{picoquant}, but instead a message is passed to \stderr{} indicating that such a record exists. If different behavior is desired (perhaps assignment of the marker to a non-existent channel), modify the function \texttt{external\_marker} in \texttt{picoquant.c}. This will cause problems with the other programs, which assume every record originates from the true signal stream, so such an alteration must be accompanied by code which appropriately splices the signal stream, for example by halting collection into a histogram and initiation of a new one.

\subsubsection{T3 timing carries units of histogram bins, not time}
In T3 modes--including T3R for the Timeharp--the pulse dimension carries units of pulse number, but the time is not strictly a time with fixed units. Instead, the specified resolution of the interactive mode is the unit of time, such that the measurement is affected directly by this choice of resolution. As a result, the T3 record more directly reflects the index of the bin the record would have fallen into in interactive mode. In \program{picoquant} this value is converted to units of \pico\second{} implicitly, but do be aware of this distinction.

\subsubsection{Translation of T3 to T2 data}
In principle, if the sync source of a T3-mode experiment arrives with perfectly uniform spacing, the pulse number can be said to represent some constant amount of time, and a T2-like record recovered. To do this, pass the flag \texttt{--to-t2} for an input of T3 data, but consider the implications of how this translation is performed (see section~\ref{sec:t3_to_t2}). 

In \program{picoquant}, the average rate of sync pulses is used to determine the time unit a pulse carries.

%For a frequency $f$ of the arrival of a sync source, pulse number $p$ and time delay $t$ on channel $c$ map as:
%\begin{equation}
%\left(c, p_{j}, t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}}{f} + t_{j}\right)
%\end{equation}
%In practice, this mapping is limited in precision in a few important ways. First, the period $1/f$ is not necessarily an integer multiple of 1\pico\second, and any precision will be lost beyond the decimal. This is not usually a problem because typical sync sources operate at 10\mega\hertz{} at most, for a precision of timing to one part in ten thousand, and a purity of the pulse train to this precision is not typical. Additionally, the timing jitter of most lasers will be well above this threshold, so this is not too great a concern.
%
%A more important concern is that of missed pulses. The T3 data reports the detected pulse number, and if a sync pulse is missed no record will exist. However, translation of any subsequent record to an absolute time will be incorrect by the period $1/f$, confusing matters where such spacing is important. Again, a well-designed system should not have problems beating this limit, but it is the greatest single source of error during the translation.
%
%Collectively, these errors can be expressed as:
%\begin{equation}
%\left(c_{j}, p_{j}+\delta p_{j}, t_{j} + \delta t_{j}\right) \rightarrow \left(c_{j}, \frac{p_{j}+\delta p_{j}}{f+\delta f} + \left(t_{j}+\delta t_{j}\right)\right)
%\end{equation}

\subsubsection{Timeharp}
The Timeharp is the least sophisticated of the three boards discussed here, and is fundamentally a histogramming board. It features two input channels, and its three modes are:
\begin{itemize}
\item interactive (thd): Collection of a histogram, using channel 0 as the sync and channel 1 as the signal.
\item continuous interactive (thc): Identical to normal interactive mode, except that the histogram is reported at the end of a user-specified time interval, repeating until halted. This feature is used for experiments requiring time resolution of a time-dependent feature, such as a fluctuating fluorescence lifetime. This feature is not supported by the existing software, due to lack of data or interest in using this mode (it is not present in the other timing boards).
\item time-tagged time-resolved (t3r): TTTR mode, equivalent to T3 mode, with channel 0 as the sync and channel 1 as the signal. Instead of reporting the delay time directly, this mode reports the index of the histogram bin an event would fall into. The time delay represented by the delay can be recovered from the header information, but for homogeneity of the treatment of T3-like data this step is not performed automatically.
\end{itemize}

\subsubsection{Picoharp}
The Picoharp features two input channels. Its three modes are:
\begin{itemize}
\item interactive (phd): Standard interactive mode, using channel 0 as the sync and channel 1 as the signal.
\item t2 (pt2): A T2 mode, with both channels treated equally and all pulse arrivals recorded. 
\item t3 (pt3): A T3 mdoe, with channel 0 as the sync and channel 1 as the signal.
\end{itemize}
In both the T2 and T3 mode, internal clocks of limited precision ($<$32 bits) are used to record the passage of time or pulses. As such, many records are devoted to recording the occurrence of an integer overflow. These records are treated by \program{picoquant} automatically, producing data streams of the form specified in section~\ref{sec:picoquant_output}.

\subsubsection{Hydraharp}
The Hydraharp features a dedicated sync channel and four input channels. Its three modes are:
\begin{itemize}
\item interactive (hhd): Standard interactive mode, with four separate histograms assigned to  the four input channels.
\item t2 (ht2): A T2 mode, with all channels treated equally, including the sync channel. If the sync channel is active, these events will be recorded, and for convenience \program{picoquant} will output each event as arriving on channel 4. This channel index can be altered by modifying value of the global variable \texttt{HH\_SYNC\_CHANNEL} (\texttt{hydraharp.h}) at compilation time. 
\item t3 (ht3): A standard t3 mode.
\end{itemize}
Future versions of the Hydraharp are being developed with extra input channels. If your model features extra channels, it should be sufficient to modify the value of \texttt{HH\_SYNC\_CHANNEL}, as the number of channels and modules is handled dynamically by \program{picoquant}.

\end{document}
